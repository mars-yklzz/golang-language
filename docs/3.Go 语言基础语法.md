# Go 语言基础语法

## 一. 变量与常量
在 Go 语言中，变量和常量的使用方式有所不同。下面分别介绍变量和常量的定义及用法。

### 1. 变量
变量用于存储可以更改的数据，其值可以在程序运行过程中发生变化。Go 中通过 var 关键字声明变量。

#### 1.1 变量声明
- 显式类型声明
```go
var a int = 10
```
- 自动类型推断： Go 允许根据初始值推断变量类型
```go
var b = "Hello"
```

- 简短声明： 使用 := 进行简短声明，仅限于函数内使用
```go
c := 3.14
```

- 多个变量声明
```go
var x, y, z int = 1, 2, 3
```

- 在函数内：
```go
x, y := 10, 20
```
#### 1.2 变量的零值
Go 的变量如果未显式初始化，会有一个默认的零值：
- 数字类型（如 int, float）：默认值是 0
- 布尔类型：默认值是 false
- 字符串类型：默认值是空字符串 ""

### 2. 常量
常量用于存储固定不变的值，其值在程序运行期间不能改变。使用 const 关键字声明常量。

#### 2.1 常量声明
- 显式类型声明
const pi float64 = 3.1415
- 自动类型推断： Go 允许根据常量的初始值推断类型：
const name = "GoLang"

#### 2.2 常量特点
- 常量的值必须在编译时确定，因此它不能依赖于运行时的计算结果。
- 常量可以是字符、字符串、布尔值或数字类型。

### 3. 枚举常量
Go 中可以利用 iota 实现枚举常量：
```go
const (
    A = iota // 0
    B        // 1
    C        // 2
)
```


### 4. Golang 的自动类型推断
在 Go 语言中，自动类型推断是通过编译器根据变量的初始值来推断变量的类型，而无需显式指定类型。这是 Go 语言的一大特性，用来简化代码书写。具体来说，Go 编译器会根据赋值表达式的类型自动推断出变量的类型。

#### 4.1 自动类型推断的两种常见方式
##### 1. var 关键字推断 当使用 var 关键字声明变量时，如果没有指定类型，Go 会根据初始化表达式推断类型：
```go
var a = 42       // 编译器推断 a 的类型为 int
var b = 3.14     // 编译器推断 b 的类型为 float64
var c = "hello"  // 编译器推断 c 的类型为 string
```
编译器根据右边的值决定左边变量的类型。例如，42 是一个整数，因此 a 的类型为 int。

##### 2. 短变量声明 := 在函数内部使用 := 符号声明变量时，也可以让 Go 自动推断类型：
```go
d := 42       // 编译器推断 d 的类型为 int
e := 3.14     // 编译器推断 e 的类型为 float64
f := true     // 编译器推断 f 的类型为 bool
```
#### 4.2 自动类型推断背后的原理
Go 的自动类型推断依赖于右侧的表达式类型。根据赋值的右侧值，编译器能推断出该变量的具体类型：
- 整数字面值：会默认推断为 int。
- 浮点数字面值：默认推断为 float64。
- 字符串字面值：推断为 string。
- 布尔值：推断为 bool。
此外，Go 语言中一些类型转换（例如从 int 到 float64）是显式的，并且需要手动进行，不会自动转换。
```go
package main

import "fmt"

func main() {
    var x = 10          // 自动推断为 int
    y := 20.5           // 自动推断为 float64
    z := "Go language"  // 自动推断为 string

    fmt.Printf("x: %T, y: %T, z: %T\n", x, y, z)  // 打印类型
}
```

在函数中，短变量声明 := 常用来快速声明并初始化变量，简化了代码。

#### 4.3 注意事项
类型推断的前提是必须有初始化值。如果没有初始化值，编译器将无法推断类型。例如，以下代码会报错：
var a        // 错误：编译器无法推断类型
推断类型与字面值一致。例如：
- 对于整数 42，推断为 int。
- 对于浮点数 3.14，推断为 float64。

### 5. 常量和变量在内存区域的存储
在 Go 语言中，变量和常量在内存中的存储方式有所不同，主要体现在生命周期、存储区域和存储方式上。了解它们在内存中的存储方式有助于优化程序的性能和内存使用。

#### 5.1 Go 内存区域划分
Go 语言中，内存通常分为三大区域：
- 全局静态区：存储全局变量和常量。这些变量和常量在程序启动时分配内存，并在程序结束时释放。
- 堆：存储动态分配的内存，通常用于需要在多个函数间共享的对象。堆上的数据需要手动管理或由 Go 的垃圾回收机制负责清理。
- 栈：用于函数调用时

#### 5.2 变量的内存存储
##### 5.2.1 全局变量：
- 全局变量声明在函数外，属于静态存储区，存储在全局静态区中。
- 这些变量在程序启动时被分配，程序结束时被释放。
- 全局变量的生命周期与程序的生命周期相同。
var globalVar int = 100  // 存储在全局静态区

##### 5.2.2 局部变量：
- 局部变量是在函数内部声明的，它们通常存储在栈上（如果不逃逸）。当函数调用时，栈帧会为局部变量分配内存；当函数返回时，这些栈内存会自动释放。
- 如果局部变量被闭包或返回给外部，Go 编译器会将其从栈移动到堆上，以确保变量在函数返回后仍然有效。
func main() {
    var localVar int = 10  // 存储在栈上
}


##### 5.2.3 指针变量：
- 指针变量存储在栈上或堆上，但它们指向的数据可以位于堆中。
- 如果变量逃逸到堆中，那么数据会存储在堆上。
func foo() *int {
    x := 42
    return &x  // x 逃逸到堆上
}


#### 5.3 常量的内存存储
##### 5.3.1 编译时常量
- 常量使用 const 关键字声明，它们通常在编译时确定，并且不会在运行时分配实际的存储空间。
- 常量在内存中的表现方式与字面量类似，在很多情况下，编译器会直接将常量的值内联到使用它的地方。
- 由于常量的值在编译时确定，因此它们不会像变量一样占用运行时内存。
const pi = 3.14159  // 编译时确定，不占用运行时内存

##### 5.3.2 只读常量
对于某些复杂常量（例如字符串），它们会存储在只读的内存区，通常位于全局静态区。尽管这些常量不会在运行时更改，它们可能仍然占用一些内存资源。
const msg = "Hello, Go!"  // 字符串常量可能存储在全局静态区

#### 5.4 栈与堆的差异
- 栈：
  - 用于局部变量的快速分配和释放。
  - 变量的生命周期与函数的调用周期相关。
  - 内存使用效率高，但大小有限。
- 堆：
  - 用于动态分配的内存，生命周期可以超出函数调用的范围。
  - 内存管理由 Go 的垃圾回收器（GC）负责。
  - 分配和释放较慢，但适合需要长期存储或跨函数调用的数据。

#### 5.5 内存逃逸分析
Go 编译器会通过逃逸分析来确定局部变量是否会逃逸到堆上。如果变量的作用域超出了当前函数（例如被返回或传递给其他 goroutine），它就会从栈上“逃逸”到堆上。
func escapeExample() *int {
    var x int = 42
    return &x  // x 逃逸到堆上
}

在上面的例子中，x 需要在函数返回后继续存活，因此会被分配到堆上。

### 6. 总结
- 变量：使用 var 或 := 声明，可以更改其值。
- 常量：使用 const 声明，值在程序运行期间不可更改。
- 变量的存储位置（栈或堆）取决于它们的声明位置及其生命周期。
  - 全局变量存储在全局静态区。
  - 局部变量一般存储在栈上，但如果逃逸则存储在堆上。
- 常量的存储方式不同，编译时常量不会占用运行时内存，复杂常量可能存储在全局静态区中。

## 二.数据类型
在 Go 语言中，数据类型分为几大类，主要包括基本数据类型、复合数据类型以及特殊数据类型。每种类型都有其特定的用途和特性，帮助程序员处理不同种类的数据。
### 1. 基本数据类型
#### 1.1 整型
Go 语言提供了多种整数类型，按有符号和无符号分类，并提供不同位数的选择：
- 有符号整型：
  - int8： 8 位有符号整数，范围为 -128 到 127
  - int16：16 位有符号整数，范围为 -32,768 到 32,767
  - int32：32 位有符号整数，范围为 -2,147,483,648 到 2,147,483,647
  - int64：64 位有符号整数，范围为 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807
  - int：根据操作系统选择 32 位或 64 位（在 32 位系统上为 int32，64 位系统上为 int64）
- 无符号整型：
  - uint8： 8 位无符号整数，范围为 0 到 255（即 byte 类型的别名）
  - uint16：16 位无符号整数，范围为 0 到 65,535
  - uint32：32 位无符号整数，范围为 0 到 4,294,967,295
  - uint64：64 位无符号整数，范围为 0 到 18,446,744,073,709,551,615
  - uint：根据操作系统选择 32 位或 64 位（在 32 位系统上为 uint32，64 位系统上为 uint64）

#### 1.2 浮点型
用于表示带有小数的数字，分为两种精度：
- float32：32 位浮点数，精度约为 7 位小数
- float64：64 位浮点数，精度约为 15 位小数

#### 1.3 复数类型
Go 还支持复数类型，提供了两种复数类型：
- complex64：实部和虚部都是 float32
- complex128：实部和虚部都是 float64

复数可以通过 complex() 函数创建，也可以直接赋值。例如：
var c1 complex64 = complex(1.2, 3.4)
var c2 complex128 = 1.2 + 3.4i

#### 1.4 布尔型
布尔型只有两个取值：true 和 false。
var isActive bool = true

#### 1.5 字符串
字符串是 UTF-8 编码的文本序列，字符串是不可变的，可以用双引号或反引号包裹。
var name string = "Go Language"
var rawString = `This is a raw string literal.`

#### 1.6 字符型
Go 语言中没有单独的 char 类型，而是用 rune（等价于 int32）表示 Unicode 码点。用于表示单个字符：
var char rune = 'A'  // 字符 'A' 的 Unicode 值是 65

### 2. 复合数据类型
#### 2.1 数组
数组是具有固定长度的同类型元素的集合，数组长度是数组类型的一部分，一旦定义，长度不能改变。
var arr [5]int = [5]int{1, 2, 3, 4, 5}

#### 2.2 切片
切片是基于数组的动态数组，长度可以变化，切片更常用于 Go 程序中。与数组不同，切片不需要指定长度。
var slice []int = []int{1, 2, 3}
slice = append(slice, 4)  // 动态扩展切片

#### 2.3 字典
map 是一种键值对的数据结构，用来高效地查找、添加和删除元素。
var m map[string]int = map[string]int{"foo": 1, "bar": 2}

#### 2.4 结构体（Struct）
struct 是一种聚合类型，用于将不同类型的数据组合在一起。可以定义具有不同字段类型的自定义数据类型。
```go
type Person struct {
    Name string
    Age  int
}
```

#### 2.5 指针
指针存储变量的内存地址。与其他语言不同，Go 不支持指针运算，但可以通过指针来改变原变量的值。
```go
var x int = 10
var p *int = &x  // p 存储 x 的内存地址
*p = 20          // 修改 x 的值为 20
```

### 3. 特殊数据类型
#### 3.1 接口
接口定义了一组方法，而不实现这些方法。实现接口的具体类型必须实现接口中定义的所有方法。
```go
type Speaker interface {
    Speak()
}
```
#### 3.2 函数
Go 中函数也是一种数据类型，可以作为参数或返回值传递给其他函数。
```go
func add(a, b int) int {
    return a + b
}
```
#### 3.3 通道
通道是 Go 语言中的一种用于并发的类型，用于在 goroutine 之间传递数据。可以是无缓冲的或有缓冲的。
```go
ch := make(chan int)
go func() {
    ch <- 42  // 发送数据到通道
}()
data := <-ch  // 从通道接收数据
```
### 4. 数据类型转换
Go 是静态类型语言，必须显式地进行类型转换。不能像某些动态语言一样自动进行隐式类型转换。
```go
var a int = 10
var b float64 = float64(a)  // int 转换为 float64
```
- 基本数据类型：包括整数、浮点数、布尔值、字符串和字符型（rune）。
- 复合数据类型：如数组、切片、结构体、map、指针等。
- 特殊数据类型：包括接口、函数、通道等。

## 三.运算符与表达式

在 Go 语言中，运算符和表达式是构成程序逻辑的基础。Go 提供了丰富的运算符来处理各种类型的数据，包括算术运算、逻辑运算、关系运算等。下面将详细介绍 Go 语言中的运算符和表达式。
### 1. 算术运算符
Go 提供了常见的算术运算符，用于基本的数学运算：
暂时无法在Lark文档外展示此内容
注意： 当两个操作数都是整数时，除法 / 会进行整数除法，结果会省略小数部分。若要保留小数，需要将其中一个操作数转换为浮点数。
```go
a := 10
b := 3
result := a / b    // 结果为 3（整数除法）
resultFloat := float64(a) / float64(b)  // 结果为 3.3333...
```
### 2. 关系运算符
关系运算符用于比较两个值，并返回布尔值 true 或 false。
暂时无法在Lark文档外展示此内容
```go
a := 5
b := 10
fmt.Println(a > b)  // 输出 false
fmt.Println(a != b) // 输出 true
```
### 3. 逻辑运算符
逻辑运算符用于连接多个布尔表达式，常用于条件判断。
暂时无法在Lark文档外展示此内容
```go
a := true
b := false
fmt.Println(a && b)  // 输出 false
fmt.Println(a || b)  // 输出 true
fmt.Println(!a)      // 输出 false
```

### 4. 位运算符
位运算符对整数类型的值按位操作，用于低级别的数据处理，如二进制操作。
暂时无法在Lark文档外展示此内容
```go
a := 6        // 110 in binary
b := 3        // 011 in binary
fmt.Println(a & b)   // 结果为 2 （010 in binary）
fmt.Println(a | b)   // 结果为 7 （111 in binary）
fmt.Println(a ^ b)   // 结果为 5 （101 in binary）
fmt.Println(a << 1)  // 结果为 12 （1100 in binary）
fmt.Println(b >> 1)  // 结果为 1 （001 in binary）
```



### 5. 赋值运算符
赋值运算符用于给变量赋值，Go 支持简化形式的运算符，如 +=，-=，*=，这些运算符同时进行运算和赋值。
暂时无法在Lark文档外展示此内容
```go
a := 10
a += 5  // 相当于 a = a + 5
fmt.Println(a)  // 输出 15
```

### 6. 指针运算符
Go 语言中通过指针运算符 & 和 * 来操作指针。
- &：取变量的内存地址。
- *：通过指针访问变量的值。
```go
a := 42
p := &a     // p 是指向 a 的指针
fmt.Println(*p)  // 通过指针 p 访问 a 的值，输出 42
*p = 21     // 修改 a 的值
fmt.Println(a)  // 输出 21
```


### 7. 其他运算符
- 取地址符 &：返回变量的内存地址。
- 指针解引用符 *：访问指针指向的值。
- 类型转换：Go 是静态类型语言，类型之间需要显式转换。
```go
var a int = 10
var b float64 = float64(a)  // 将 int 转为 float64
```


### 8. 表达式
表达式是由运算符和操作数组成的一个代码片段，用于求值。它可以是一个简单的字面量、变量，也可以是多个变量和运算符的组合。
- 算术表达式：由算术运算符组成的表达式。
result := (a + b) * c
- 关系表达式：用于比较值。
```go
if a > b {
    fmt.Println("a is greater than b")
}
```
- 逻辑表达式：由逻辑运算符组成，用于条件判断。
```go
if a > b && c < d {
    fmt.Println("Condition met")
}
```
### 9. 总结
Go 语言中的运算符涵盖了从基本的算术、关系、逻辑运算到位运算、指针运算等多种操作，可以构成各种表达式来满足不同的编程需求。理解和合理使用这些运算符是编写高效 Go 代码的关键。

## 四.分支流程控制
Go 语言提供了多种分支流程控制语句，用于根据条件执行不同的代码块。常见的分支控制语句包括 if、else、switch、select 等。下面将详细介绍这些控制语句的使用。

### 1. if 语句
if 语句用于根据布尔条件执行代码块。如果条件为 true，则执行 if 语句中的代码块。
语法结构：
if condition {
    // 如果条件为 true，执行此代码块
}

示例：
```go
a := 10
if a > 5 {
    fmt.Println("a 大于 5")
}
```

带有初始化语句的 if：
在 if 语句中可以包含一个初始化语句，这个语句在条件判断之前执行。这个特性使得 Go 的 if 更加简洁。
```go
if err := doSomething(); err != nil {
    fmt.Println("发生错误:", err)
}
```

这里 doSomething() 的结果被赋值给变量 err，然后在 if 语句中进行条件判断。

### 2. if...else 语句
if...else 语句用于在条件为 false 时执行另一个代码块。
语法结构：
```go
if condition {
    // 如果条件为 true，执行此代码块
} else {
    // 如果条件为 false，执行此代码块
}
```

示例：
```go
a := 10
if a > 20 {
    fmt.Println("a 大于 20")
} else {
    fmt.Println("a 小于或等于 20")
}
```

### 3. if...else if...else 语句
if...else if...else 语句用于处理多个条件的情况。
语法结构：
```go
if condition1 {
    // 如果 condition1 为 true，执行此代码块
} else if condition2 {
    // 如果 condition2 为 true，执行此代码块
} else {
    // 如果以上条件都为 false，执行此代码块
}
```

示例：
```go
a := 15
if a > 20 {
    fmt.Println("a 大于 20")
} else if a > 10 {
    fmt.Println("a 大于 10 但小于等于 20")
} else {
    fmt.Println("a 小于或等于 10")
}
```

### 4. switch 语句
switch 语句用于简化多个条件的判断，它相比于多个 if...else if 更加清晰和易读。
语法结构：
```go
switch variable {
case value1:
    // 如果 variable 等于 value1，执行此代码块
case value2:
    // 如果 variable 等于 value2，执行此代码块
default:
    // 如果所有 case 都不匹配，执行此代码块
}
```

示例：
```go
day := "Monday"
switch day {
case "Monday":
    fmt.Println("今天是周一")
case "Tuesday":
    fmt.Println("今天是周二")
default:
    fmt.Println("今天是其他日子")
}
```

不带表达式的 switch：
switch 语句也可以省略表达式，此时它等价于 switch true，可以用于多个条件判断。
```go
a := 10
switch {
case a > 15:
    fmt.Println("a 大于 15")
case a > 5:
    fmt.Println("a 大于 5 但小于等于 15")
default:
    fmt.Println("a 小于等于 5")
}
```

fallthrough 语句：
在 Go 中，switch 语句在匹配到某个 case 后会自动终止，不会像 C 语言一样继续执行后续的 case。如果你需要继续执行下一个 case，可以使用 fallthrough。
```go
a := 1
switch a {
case 1:
    fmt.Println("a 是 1")
    fallthrough  // 继续执行下一个 case
case 2:
    fmt.Println("a 是 2")
default:
    fmt.Println("a 是其他值")
}
```

输出结果：
a 是 1
a 是 2
### 5. select 语句
select 语句是 Go 特有的，用于处理多个通道（channel）的通信操作。它类似于 switch，但每个 case 都必须是一个通道操作。
语法结构：
```go
select {
case <-ch1:
    // 如果 ch1 通道可读取数据，执行此代码块
case ch2 <- value:
    // 如果 ch2 通道可写入数据，执行此代码块
default:
    // 如果没有通道可用，执行此代码块
}
```

示例：
```go
ch1 := make(chan int)
ch2 := make(chan int)

go func() {
    ch1 <- 1
}()

go func() {
    ch2 <- 2
}()

select {
case val := <-ch1:
    fmt.Println("从 ch1 读取到:", val)
case val := <-ch2:
    fmt.Println("从 ch2 读取到:", val)
default:
    fmt.Println("没有通道可用")
}
```
### 6. 循环控制中的 break 和 continue
在 Go 的分支控制中，还可以结合循环控制使用 break 和 continue。
- break：用于立即终止当前的 for、switch 或 select 语句。
- continue：用于跳过当前循环，继续下一次循环。

break 示例：
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 退出循环
    }
    fmt.Println(i)
}
```

continue 示例：
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        continue  // 跳过本次循环
    }
    fmt.Println(i)
}
```

### 7. For 循环
在 Go 语言中，循环结构主要通过 for 语句实现。Go 没有像其他编程语言中的 while 和 do-while 循环，而是用 for 语句可以完成所有的循环需求。接下来我们来详细介绍 Go 的 for 循环语法和不同形式的循环用法。
7.1 基本的 for 循环
Go 中最常见的 for 循环结构类似于其他语言的 for 循环，包括初始化语句、条件表达式和递增语句。
语法结构：
```go
for 初始化语句; 条件表达式; 递增语句 {
    // 循环体
}
```

示例：
```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```

输出结果：
0
1
2
3
4

在这个例子中，i 被初始化为 0，循环条件为 i < 5，每次循环结束后 i++，直到条件不满足为止。
7.2 省略部分条件的 for 循环
Go 允许省略 for 循环中的某些部分，可以只包含条件表达式，或者是一个无限循环。
只有条件表达式的 for 循环：

这种形式类似于其他语言中的 while 循环。

语法结构：
for 条件表达式 {
    // 循环体
}

示例：
```go
i := 0
for i < 5 {
    fmt.Println(i)
    i++
}
```

输出结果与上面相同：
```go
0
1
2
3
4
```



#### 7.3 无限循环：
如果省略所有的循环条件，for 循环将会变成一个无限循环，必须通过 break 语句手动退出循环。
示例：
```go 
for {
    fmt.Println("无限循环")
    break  // 手动退出循环
}
```


#### 7.4 for...range 循环
Go 中的 for...range 语句用于遍历数组、切片（slice）、map、字符串等集合类型的数据。range 在遍历过程中返回两个值：索引（或键）和值。
遍历数组或切片：
```go
nums := []int{1, 2, 3, 4, 5}
for index, value := range nums {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}
```
输出结果：
```go
索引: 0, 值: 1
索引: 1, 值: 2
索引: 2, 值: 3
索引: 3, 值: 4
索引: 4, 值: 5
```

如果你只关心值而不关心索引，可以使用 _ 忽略索引。
```go
for _, value := range nums {
    fmt.Println(value)
}
```


遍历字符串：
在遍历字符串时，range 返回字符的索引和 Unicode 码点（rune）。
```go
str := "Hello"
for index, runeValue := range str {
    fmt.Printf("索引: %d, 字符: %c\n", index, runeValue)
}
```

输出结果：
```
索引: 0, 字符: H
索引: 1, 字符: e
索引: 2, 字符: l
索引: 3, 字符: l
索引: 4, 字符: o
```

遍历 map：
for...range 也可以用于遍历 map，会返回键值对。
```go
myMap := map[string]int{"Alice": 25, "Bob": 30, "Carol": 35}
for key, value := range myMap {
    fmt.Printf("键: %s, 值: %d\n", key, value)
}
```

输出结果：
```go
键: Alice, 值: 25
键: Bob, 值: 30
键: Carol, 值: 35
```

7.5 控制循环的语句
break 语句
break 语句用于立即退出循环。
```go
for i := 0; i < 10; i++ {
    if i == 5 {
        break  // 当 i 等于 5 时退出循环
    }
    fmt.Println(i)
}
```
输出结果：
```go
0
1
2
3
4
```

continue 语句
continue 语句用于跳过当前循环的剩余部分，直接进入下一次循环。
```go
for i := 0; i < 5; i++ {
    if i == 3 {
        continue  // 跳过 i 等于 3 的那次循环
    }
    fmt.Println(i)
}
```

输出结果：
```go
0
1
2
4
```

goto 语句
goto 语句用于跳转到代码中的某个标签（label）。虽然 goto 并不常用，但在某些情况下可以简化复杂的流程控制。
```go
i := 0
for i < 5 {
    if i == 3 {
        goto label  // 当 i 等于 3 时跳转到 label 标签
    }
    fmt.Println(i)
    i++
}

label:
fmt.Println("跳过了 i = 3")
```

输出结果：
```go
0
1
2
跳过了 i = 3
```

#### 7.6 嵌套循环
Go 允许在循环内嵌套其他循环，以实现更复杂的逻辑。可以结合 break 和 continue 控制循环行为。
```go
for i := 1; i <= 3; i++ {
    for j := 1; j <= 3; j++ {
        fmt.Printf("i: %d, j: %d\n", i, j)
    }
}
```
输出结果：
i: 1, j: 1
i: 1, j: 2
i: 1, j: 3
i: 2, j: 1
i: 2, j: 2
i: 2, j: 3
i: 3, j: 1
i: 3, j: 2
i: 3, j: 3
#### 7.7 循环配合 defer 使用
在 for 循环中，defer 语句会在当前函数返回之前按照后进先出的顺序执行。通常用于在循环中执行一些延迟操作，比如文件关闭、资源释放等。
```go
for i := 0; i < 3; i++ {
    defer fmt.Println("延迟执行:", i)
}
```

输出结果（延迟输出从最后一个 defer 开始）：
```go
for i := 0; i < 3; i++ {
    defer fmt.Println("延迟执行:", i)
}
```


### 8. 总结
- if 语句：用于简单条件判断，支持初始化语句。
- if...else if...else 语句：处理多个条件的判断。
- switch 语句：替代多个 if...else if 的简洁方式，支持 fallthrough 和不带表达式的用法。
- select 语句：用于处理通道的多路复用，是 Go 并发编程中的关键部分。
- break 和 continue：用于循环控制，break 退出循环，continue 跳过当前循环。

## 五. 小结
本文咱们讲解了 golang 最基础的语法，下一讲开始，我们将开启 go 高阶部分。
# Go 数组与切片

## 一.基本概念

在 Go 语言中，数组和切片是两个非常重要的集合数据结构。它们在存储和操作数据方面有着不同的特性和用法。

### 1. 数组（Array）

#### 1.1 **定义与特点**：

- 数组是定长的，即长度在定义时就已经固定，无法动态调整。
- 数组的每个元素必须是相同类型的。
- 数组是值类型，复制数组会产生一个新的副本，而不是引用同一个数组。

#### 1.2 **语法**

```Go
var arr [5]int // 定义一个长度为 5 的整数数组，所有元素默认值为 0
arr := [3]string{"Go", "Rust", "Python"} // 定义并初始化一个长度为 3 的字符串数组
```

#### 1.3 **访问和修改数组元素**

使用索引访问数组元素，索引从 0 开始

```Go
arr[0] = 100 // 修改第一个元素
fmt.Println(arr[0]) // 访问第一个元素
```

#### 1.4 **数组的长度**

通过 `len()` 函数获取数组的长度

```Go
fmt.Println(len(arr)) // 输出数组长度
```

#### 1.5  数组的遍历

可以使用 `for` 循环或 `range` 关键字遍历数组

```Go
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
}

for index, value := range arr {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}
```

#### 1.6 数组作为函数参数

数组在作为函数参数时，传递的是一个副本。如果需要修改原数组，可以使用指针

```Go
func modifyArray(arr [5]int) {
    arr[0] = 100 // 修改的是副本，不会影响原数组
}

func modifyArrayByPointer(arr *[5]int) {
    (*arr)[0] = 100 // 通过指针修改原数组
}
```

#### 1.7  多维数组

Go 语言支持多维数组，可以定义二维数组、三维数组等

```Go
var matrix [3][3]int // 定义一个 3x3 的二维数组
matrix[0][1] = 1 // 设置第一行第二列的值
```

#### 1.8 数组的内存布局

数组在内存中是连续存储的，这使得对数组的访问速度非常快。可以使用 `unsafe` 包查看内存地址（但需谨慎使用）

```Go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    arr := [3]int{1, 2, 3}
    for i := 0; i < len(arr); i++ {
        fmt.Printf("元素: %d, 地址: %p\n", arr[i], &arr[i])
    }
    fmt.Printf("数组占用的内存大小: %d bytes\n", unsafe.Sizeof(arr))
}
```

#### 1.9 组合与嵌套数组

可以将数组作为其他数组的元素，实现嵌套结构

```Go
type Student struct {
    name  string
    scores [3]int // 每个学生有 3 门课程的成绩
}

var students [2]Student
students[0] = Student{name: "Alice", scores: [3]int{90, 80, 85}}
students[1] = Student{name: "Bob", scores: [3]int{70, 75, 80}}
```

#### 1.10  数组的常见操作

可以实现一些常见的数组操作，比如反转数组、查找元素等

```Go
// 反转数组
func reverseArray(arr *[5]int) {
    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
        arr[i], arr[j] = arr[j], arr[i]
    }
}
```

### 2  切片（Slice）

#### 2.1 **定义与特点**

- 切片是一个动态数组，可以根据需求动态增减长度。
- 切片是引用类型，它是对底层数组的引用，因此修改切片会影响底层数组的内容。
- 切片由三个部分组成：指向底层数组的指针、切片的长度和切片的容量。

#### 2.2 **语法**

```Go
var s []int // 定义一个整数切片
s := []int{1, 2, 3, 4, 5} // 定义并初始化切片
```

#### 2.3 切片的声明与初始化

切片可以通过几种方式声明和初始化：

##### 2.3.1 使用内置函数 `make`

```Go
s := make([]int, 5) // 创建一个长度为 5 的切片，默认值为 0
s2 := make([]int, 5, 10) // 创建一个长度为 5，容量为 10 的切片
```

##### 2.3.2 使用简短声明方式

```Go
s := []int{1, 2, 3, 4, 5} // 定义并初始化一个切片
```

##### 2.3.3 从数组或其他切片创建

```Go
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // 创建一个切片，包含索引 1 到 3 的元素
```

#### 2.4 **切片的基本操作**

##### 2.4.1 访问与修改元素

```Go
s[0] = 10 // 修改第一个元素
fmt.Println(s[0]) // 访问第一个元素
```

##### 2.4.2  切片的长度与容量

- `len(s)`：获取切片的长度。
- `cap(s)`：获取切片的容量，即从切片起始位置到底层数组末尾的元素个数。

```Go
fmt.Println("长度:", len(s), "容量:", cap(s))
```

#### 2.5 切片的遍历

可以使用 `for` 循环或 `range` 遍历切片：

```Go
for i := 0; i < len(s); i++ {
    fmt.Println(s[i])
}

for index, value := range s {
    fmt.Printf("索引: %d, 值: %d\n", index, value)
}
```

#### 2.6 **修改切片内容**

切片修改会直接影响底层数组的内容，因为它是引用类型。

```Go
s[0] = 100 // 修改切片 s，会影响底层数组 arr
```

#### 2.7 **追加元素**

可以使用内置函数 `append` 向切片添加元素，切片容量不足时，Go 会自动扩容。

```Go
s = append(s, 6) // 向切片 s 追加元素 6
```

#### 2.8 切片的复制

可以使用内置函数 `copy` 来复制切片内容

```Go
s1 := []int{1, 2, 3}
s2 := make([]int, len(s1))
copy(s2, s1) // 复制 s1 的内容到 s2
```

#### 2.9 切片的内存布局

切片的底层实现是指向数组的指针，切片的数据结构如下：

```Go
type sliceHeader struct {
    Data uintptr // 指向底层数组的指针
    Len  int     // 切片的长度
    Cap  int     // 切片的容量
}
```

#### 2.10 切片的扩容

当切片的容量不足时，使用 `append` 函数会导致 Go 语言自动进行扩容。扩容的策略一般是将容量增加一倍，但并不总是如此，具体策略可能因实现而异。

#### 2.11 切片的切片

切片可以被进一步切片，产生新的切片：

```Go
s := []int{1, 2, 3, 4, 5}
s1 := s[1:4] // s1 为 [2, 3, 4]
s2 := s[2:]  // s2 为 [3, 4, 5]
```

#### 2.12  切片作为函数参数

切片可以作为函数参数，并可以直接在函数内部修改。由于切片是引用类型，函数内的修改会影响原切片

```Go
func modifySlice(s []int) {
    s[0] = 100 // 修改切片的第一个元素
}

s := []int{1, 2, 3}
modifySlice(s)
fmt.Println(s) // 输出 [100, 2, 3]
```

#### 2.13  切片的常见模式

- **动态数组**：切片可以用作动态数组，方便管理一组不固定数量的元素。
- **实现栈和队列**：切片可以实现栈（后进先出）和队列（先进先出）等数据结构。

#### 2.14  使用切片进行数据处理

切片在数据处理方面非常灵活，可以轻松地进行过滤、映射等操作。例如，过滤切片中的偶数

```Go
func filterEvenNumbers(s []int) []int {
    var result []int
    for _, v := range s {
        if v%2 == 0 {
            result = append(result, v)
        }
    }
    return result
}

s := []int{1, 2, 3, 4, 5}
evens := filterEvenNumbers(s)
fmt.Println(evens) // 输出 [2, 4]
```

### 3. 数组与切片表层比较

- **长度**：数组长度固定，切片长度可变。
- **值类型 vs 引用类型**：数组是值类型，复制时是完全独立的副本；切片是引用类型，多个切片可以共享同一个底层数组。
- **内存效率**：切片更加灵活，通常在实际开发中更常用，因为它可以动态扩展，不需要在一开始就指定固定的长度。

**示例代码**

```Go
package main

import "fmt"

func main() {
    // 数组示例
    arr := [5]int{1, 2, 3, 4, 5}
    fmt.Println("数组:", arr)

    // 切片示例
    s := arr[1:4] // 创建一个切片
    fmt.Println("切片:", s)
    s = append(s, 6) // 向切片添加元素
    fmt.Println("扩展后的切片:", s)
    fmt.Println("修改切片影响底层数组:")
    s[0] = 100
    fmt.Println("切片:", s)
    fmt.Println("数组:", arr)
}
```

通过这个示例，可以看到切片的灵活性和数组的底层特性。



### 4. **make 和 new 什么区别**

在 Go 语言中，`make` 和 `new` 是两种用于分配内存的内置函数，但它们的用途和返回值有所不同。

####  4.1.用途

- **new**：
  - 用于分配内存并初始化为零值。
  - 主要用于基本类型、结构体等。
  - 返回一个指向类型的指针。
- **make**：
  - 专门用于初始化切片、映射（map）和通道（channel）。
  - 返回的是已初始化的（非零）切片、映射或通道本身，而不是指针。

####  4.2.返回值

- **new**：
  - 返回的是一个指向新分配的类型的指针。
  - 例如，`new(int)` 返回一个指向 `int` 类型的指针。
- **make**：
  - 返回的是切片、映射或通道的引用（不是指针），并已被初始化。
  - 例如，`make([]int, 5)` 返回一个长度为 5 的切片。

####  4.3.语法示例

以下是对 `new` 和 `make` 的示例，说明它们的用法和返回值：

- 使用 `new`

```Go
package main

import "fmt"

func main() {
    // 使用 new 分配一个 int 的指针
    p := new(int) // p 是 *int 类型
    *p = 42       // 设置指针指向的值
    fmt.Println(*p) // 输出 42
}
```

- 使用 `make`

```Go
package main

import "fmt"

func main() {
    // 使用 make 初始化切片
    s := make([]int, 5) // s 是 []int 类型，长度为 5，默认值为 0
    fmt.Println(s) // 输出 [0 0 0 0 0]

    // 使用 make 初始化映射
    m := make(map[string]int) // m 是 map[string]int 类型
    m["key"] = 1
    fmt.Println(m) // 输出 map[key:1]

    // 使用 make 初始化通道
    c := make(chan int) // c 是 chan int 类型
    go func() {
        c <- 1 // 在一个 goroutine 中发送数据
    }
    fmt.Println(<-c) // 输出 1
}
```

####  4.4. 总结

- 使用 `new` 时，通常是为了获得一个指向某个类型的指针，而它会返回一个零值。
- 使用 `make` 时，主要是为了初始化切片、映射和通道，以便在之后使用。`make` 返回的是已经初始化的对象，而不是指针。

## 二. Slice 深入

### 1. 切片的数据结构

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。



Slice 的数据结构定义如下:

```Go
type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}
```

切片的结构体由3部分构成，Pointer 是指向一个数组的指针，len 代表当前切片的长度，cap 是当前切片的容量。cap 总是大于等于 len 的。

![img](https://github.com/the-web3/golang-language/tree/main/docs/imgs/切片的数据结构.png)


### 2. 切片操作底层原理

#### 2.1  **创建切片**

创建切片有两种形式，make 创建切片，空切片。

```Go
func makeslice(et *_type, len, cap int) slice {
      // 根据切片的数据类型，获取切片的最大容量
      maxElements := maxSliceCap(et.size)
      // 比较切片的长度，长度值域应该在[0,maxElements]之间
      if len < 0 || uintptr(len) > maxElements {
                panic(errorString("makeslice: len out of range"))
      }
      // 比较切片的容量，容量值域应该在[len,maxElements]之间
      if cap < len || uintptr(cap) > maxElements {
          panic(errorString("makeslice: cap out of range"))
      }
      // 根据切片的容量申请内存
      p := mallocgc(et.size*uintptr(cap), et, true)
      // 返回申请好内存的切片的首地址
      return slice{p, len, cap}
}
```

#### 2.2 **nil与空切片**

nil 与空切片在项目中也是比较常用的，比如一些接口需要返回一个切片，但是程序出错时，就需要返回一个nil 的切片或者带有空值的切片。


![img](https://github.com/the-web3/golang-language/tree/main/docs/imgs/nil与空切片1.png)

![img](https://github.com/the-web3/golang-language/tree/main/docs/imgs/nil与空切片2.png)


空切片和 nil 切片的区别在于，空切片指向的地址不是nil，指向的是一个内存地址，但是它没有分配任何内存空间，即底层元素包含0个元素。



#### 2.3 **拷贝切片**

```Go
func slicecopy(to, fm slice, width uintptr) int {
    // 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return 
    if fm.len == 0 || to.len == 0 {
        return 0
    }
    // n 记录下源切片或者目标切片较短的那一个的长度
    n := fm.len
    if to.len < n {
        n = to.len
    }
    // 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度
    if width == 0 {
        return n
    }
    // 如果开启了竞争检测
    if raceenabled {
        callerpc := getcallerpc(unsafe.Pointer(&to))
        pc := funcPC(slicecopy)
        racewriterangepc(to.array, uintptr(n*int(width)), callerpc, pc)
        racereadrangepc(fm.array, uintptr(n*int(width)), callerpc, pc)
    }
    // 如果开启了 The memory sanitizer (msan)
    if msanenabled {
        msanwrite(to.array, uintptr(n*int(width)))
        msanread(fm.array, uintptr(n*int(width)))
    }

    size := uintptr(n) * width
    if size == 1 { 
        // TODO: is this still worth it with new memmove impl?
        // 如果只有一个元素，那么指针直接转换即可
        *(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer
    } else {
        // 如果不止一个元素，那么就把 size 个 bytes 从 fm.array 地址开始，拷贝到 to.array 地址之后
        memmove(to.array, fm.array, size)
    }
    return n
}
```

在这个方法中，slicecopy 方法会把源切片值(即 fm Slice )中的元素复制到目标切片(即 to Slice )中，并返回被复制的元素个数，copy 的两个类型必须一致。slicecopy 方法最终的复制结果取决于较短的那个切片，当较短的切片复制完成，整个复制过程就全部完成了。 


![img](https://github.com/the-web3/golang-language/tree/main/docs/imgs/拷贝切片.png)


#### 2.4 **切片扩容**

```Go
func growslice(et *_type, old slice, cap int) slice {
    if raceenabled {
        callerpc := getcallerpc(unsafe.Pointer(&et))
        racereadrangepc(old.array, uintptr(old.len*int(et.size)), callerpc, funcPC(growslice))
    }
    if msanenabled {
        msanread(old.array, uintptr(old.len*int(et.size)))
    }

    if et.size == 0 {
        // 如果新要扩容的容量比原来的容量还要小，这代表要缩容了，那么可以直接报panic了。
        if cap < old.cap {
            panic(errorString("growslice: cap out of range"))
        }

        // 如果当前切片的大小为0，还调用了扩容方法，那么就新生成一个新的容量的切片返回。
        return slice{unsafe.Pointer(&zerobase), old.len, cap}
    }

  // 这里就是扩容的策略
    newcap := old.cap
    doublecap := newcap + newcap
    if cap > doublecap {
        newcap = cap
    } else {
        if old.len < 1024 {
            newcap = doublecap
        } else {
            for newcap < cap {
                newcap += newcap / 4
            }
        }
    }

    // 计算新的切片的容量，长度。
    var lenmem, newlenmem, capmem uintptr
    const ptrSize = unsafe.Sizeof((*byte)(nil))
    switch et.size {
    case 1:
        lenmem = uintptr(old.len)
        newlenmem = uintptr(cap)
        capmem = roundupsize(uintptr(newcap))
        newcap = int(capmem)
    case ptrSize:
        lenmem = uintptr(old.len) * ptrSize
        newlenmem = uintptr(cap) * ptrSize
        capmem = roundupsize(uintptr(newcap) * ptrSize)
        newcap = int(capmem / ptrSize)
    default:
        lenmem = uintptr(old.len) * et.size
        newlenmem = uintptr(cap) * et.size
        capmem = roundupsize(uintptr(newcap) * et.size)
        newcap = int(capmem / et.size)
    }

    // 判断非法的值，保证容量是在增加，并且容量不超过最大容量
    if cap < old.cap || uintptr(newcap) > maxSliceCap(et.size) {
        panic(errorString("growslice: cap out of range"))
    }

    var p unsafe.Pointer
    if et.kind&kindNoPointers != 0 {
        // 在老的切片后面继续扩充容量
        p = mallocgc(capmem, nil, false)
        // 将 lenmem 这个多个 bytes 从 old.array地址 拷贝到 p 的地址处
        memmove(p, old.array, lenmem)
        // 先将 P 地址加上新的容量得到新切片容量的地址，然后将新切片容量地址后面的 capmem-newlenmem 个 bytes 这块内存初始化。为之后继续 append() 操作腾出空间。
        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
    } else {
        // 重新申请新的数组给新切片
        // 重新申请 capmen 这个大的内存地址，并且初始化为0值
        p = mallocgc(capmem, et, true)
        if !writeBarrier.enabled {
            // 如果还不能打开写锁，那么只能把 lenmem 大小的 bytes 字节从 old.array 拷贝到 p 的地址处
            memmove(p, old.array, lenmem)
        } else {
            // 循环拷贝老的切片的值
            for i := uintptr(0); i < lenmem; i += et.size {
                typedmemmove(et, add(p, i), add(old.array, i))
            }
        }
    }
    // 返回最终新切片，容量更新为最新扩容之后的容量
    return slice{p, old.len, newcap}
}
```

Go 中切片扩容的策略是这样的：

如果切片的容量小于 1024 个元素，于是扩容的时候就翻倍增加容量。上面那个例子也验证了这一情况，总容量从原来的4个翻倍到现在的8个。

一旦元素个数超过 1024 个元素，那么增长因子就变成 1.25 ，即每次增加原来容量的四分之一。

注意：扩容扩大的容量都是针对原来的容量而言的，而不是针对原来数组的长度而言的。



## 三. 小结

本节我们讲解了数组和切片，重点内容如下

- 数组和切片的基本概念
- 数组和切片的常用方法
- slice 底层实现
- 零切片、空切片、nil切片是什么
- array 和 slice的区别
- slice 的扩容机制



## 四. 本节作业

- **翻转字符串**
- **判断两个给定的字符串排序后是否一致**
- **字符串替换问题**
- **slice 底层实现**
- **怎么判断一个数组是否已经排序**
- **array 和 slice的区别**
- **零切片、空切片、nil切片是什么**
- **slice 深拷贝和浅拷贝**
- **Slice 创建的时候的几个参数什么含义**
- **slice，len，cap，共享，扩容**
- **使用值为 nil 的 sice、map 会发生什么**
- **slice 的扩容机制是什么**
- **array 类型的值作为函数参数是引用传递还是值传递？**





